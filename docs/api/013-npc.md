# NPC System

NPCs are non-player characters that can talk, move, and make decisions based on game state. The NPC system combines three layers: **registration** (who the NPC is), **behavior trees** (how they decide what to do), and **beat graph actions** (scripted story moments).

**Source**: `src/components/NPC.ts`, `src/components/NPCBehavior.ts`, `src/systems/BehaviorTreeSystem.ts`, `src/behavior/`

## Overview: Who Does What

The NPC system has two "directors" that control NPC behavior. Understanding the split is key:

| System | Role | When it runs | Examples |
|--------|------|-------------|----------|
| **Beat Graph Actions** | The director. One-shot commands tied to quest progression. | When a beat node is entered or completed. | "Walk to the bridge", "Give player a key", "Play a sound" |
| **Behavior Tree** | The actor. Ongoing decision-making based on current world state. | On interaction (player presses E) or continuously (ticked). | "If quest X is active, say dialogue Y", "Idle with lean animation" |

**Beat graph actions** fire once at a specific story moment. They're imperative: "do this now."

**Behavior trees** define conditional, ongoing behavior. They're declarative: "given the current state of the world, here's what I should be doing."

### When to use which

- **NPC walks somewhere after a quest event** -> Beat graph `onComplete: moveNpc`
- **NPC says different things depending on quest progress** -> Behavior tree `onInteraction`
- **NPC idles with a specific animation between story beats** -> Behavior tree `continuous`
- **NPC gives player an item when a quest node completes** -> Beat graph `onComplete: giveItem`
- **NPC reacts differently to player based on inventory/flags** -> Behavior tree `onInteraction`

## NPC Registration

NPCs are registered through the editor or project content. Each NPC becomes an entity with `NPC`, `Position`, `Renderable`, and optionally `NPCBehavior` and `NPCMovement` components.

### Editor Fields

| Field | Type | Description |
|-------|------|-------------|
| `name` | `string` | Display name |
| `portrait` | `string?` | Path to portrait image |
| `description` | `string?` | Character notes (not shown in-game) |
| `faction` | `string?` | Faction tag for filtering |
| `defaultDialogue` | `string?` | Fallback dialogue tree ID |
| `behaviorTree` | `BTNode?` | Root of the behavior tree |
| `behaviorMode` | `'onInteraction' \| 'continuous'` | When the tree evaluates |

## Behavior Trees

A behavior tree is a decision-making structure. The tree is evaluated top-down, and each node returns `success`, `failure`, or `running`.

### Node Types

**Control nodes** (blue in editor) - organize child nodes:

| Node | Behavior | Use for |
|------|----------|---------|
| **Selector** | Tries children left-to-right, returns first success | "Try A, else try B, else try C" |
| **Sequence** | Runs children left-to-right, fails on first failure | "Check condition AND do action" |
| **Parallel** | Runs all children, configurable success policy | "Do multiple things at once" |

**Decorator nodes** (orange) - wrap a single child:

| Node | Behavior |
|------|----------|
| **Inverter** | Flips success/failure |
| **Repeater** | Runs child N times |
| **Succeeder** | Always returns success |

**Condition nodes** (yellow) - check game state, return success or failure. All built-in conditions are evaluated through the [World State System](./014-world-state.md):

| Condition | Fields | What it checks |
|-----------|--------|----------------|
| `questStage` | questId, stageId, nodeId?, state | Is a quest stage (or specific beat node) active/completed? |
| `hasItem` | itemId, count? | Does the player have an item? |
| `hasFlag` | flag, value? | Is a game flag set? |
| `timeOfDay` | value | What time of day is it? |
| `atLocation` | locationId, radius? | Is the NPC at a location? |
| `custom` | check | Custom condition handler |

**Action nodes** (green) - things the NPC does:

| Action | Fields | Behavior |
|--------|--------|----------|
| `dialogue` | dialogueId | Start a dialogue tree |
| `moveTo` | target (x,y,z) | Walk to a position |
| `wait` | seconds | Pause for a duration |
| `animate` | animation | Play an animation |
| `lookAt` | target | Face a target |
| `setFlag` | flag, value | Set a game flag |
| `emitEvent` | event | Fire a custom event |
| `custom` | handler | Custom action handler |

### Behavior Modes

**On Interaction** - the tree evaluates once when the player interacts with the NPC. The first `dialogue` action found determines what the NPC says. If the tree produces no action, the NPC's `defaultDialogue` is used as fallback.

**Continuous** - the tree ticks on a loop (default every 1000ms). Handles `running` states for async actions like `moveTo` and `wait`. Use this for NPCs that need to do things on their own (patrol, idle animations, react to world changes).

Both modes can coexist on the same tree: a continuous tree will also be evaluated on interaction. Design the tree so the interaction path (dialogue actions) and the continuous path (movement/animation) don't conflict.

### Interaction Priority Chain

When the player interacts with an NPC, the engine checks in order:

1. **Quest dialogue** - does any active quest have a talk objective targeting this NPC with a specific dialogue override?
2. **Behavior tree** - evaluate the NPC's BT; if it returns a `dialogue` action, use that
3. **Default dialogue** - fall back to the NPC's `defaultDialogue`

### Checking Beat Node State

The `questStage` condition can check state at two granularities:

**Stage-level**: set `questId` and `stageId`. Returns whether the entire stage is active or completed.

**Beat node-level**: set `questId`, `stageId`, AND `nodeId`. Returns whether a specific beat node within the stage is active or completed. Use this to react to individual quest objectives.

```
Condition: questStage
  questId: "flying-home"
  stageId: "build-resonance"
  nodeId:  "talk-to-guard"     <- UUID of the specific beat node
  state:   "completed"
```

In the editor, the Quest Stage condition has cascading selectors: Quest -> Stage -> Beat Node (optional).

## Example: Quest-Reactive NPC

Scenario: Ethan is a quest NPC. After the player talks to him (beat node), he walks to a spot, idles there, and says different things when approached depending on quest progress.

### Beat Graph Setup (the director)

In quest stage 1, the beat graph has:

```
[Talk to Ethan] ---> [Find the artifact] ---> [Return to Ethan]
     |
     onComplete: moveNpc(ethan, 10, 0, 5)
```

When the player completes the "Talk to Ethan" node, the `moveNpc` action fires and Ethan walks to position (10, 0, 5). This is a one-shot story event.

### Behavior Tree Setup (the actor)

Ethan's behavior tree handles what he does/says between story beats:

```
Selector (root)
├── Sequence: "Has the artifact"
│   ├── Condition: questStage(quest, stage1, "find-artifact", completed)
│   └── Action: dialogue(ethan-artifact-found)
│
├── Sequence: "Waiting for artifact"
│   ├── Condition: questStage(quest, stage1, "talk-to-ethan", completed)
│   └── Action: dialogue(ethan-waiting)
│
└── Action: dialogue(ethan-default-greeting)
```

Mode: **On Interaction**

When the player approaches Ethan:
- If the "find artifact" beat node is completed -> Ethan says the "artifact found" dialogue
- If only the "talk to Ethan" beat node is completed (artifact not found yet) -> Ethan says "I'm waiting" dialogue
- Otherwise -> default greeting

### Adding Idle Animation

If you also want Ethan to play a specific idle animation while waiting, change mode to **Continuous** and restructure:

```
Selector (root)
├── Sequence: "Has the artifact"
│   ├── Condition: questStage(quest, stage1, "find-artifact", completed)
│   └── Action: dialogue(ethan-artifact-found)
│
├── Sequence: "Waiting for artifact - idle"
│   ├── Condition: questStage(quest, stage1, "talk-to-ethan", completed)
│   └── Action: animate(lean-on-wall)
│
└── Action: dialogue(ethan-default-greeting)
```

The continuous tick keeps Ethan in the lean animation. When the player interacts, the same tree evaluates and the first matching dialogue branch fires.

### Later: Ethan Walks to a Meeting Point

When a later beat node activates (e.g., "Return to Ethan"), use another `moveNpc` beat action:

```
[Return to Ethan]
     |
     onEnter: moveNpc(ethan, 0, 0, 0)   <- moves Ethan to the meeting spot
```

The player's quest tracker tells them where to go. Ethan is already there (or walking there) when they arrive.

## Engine API

### Engine Methods

```typescript
// Evaluate an NPC's behavior tree and return the resulting action (if any)
engine.evaluateNPCBehavior(npcId: string): BTAction | null

// Register a custom condition checker
engine.setBTConditionChecker(checker: (npcId: string, condition: BTCondition) => boolean): void

// Register a custom action handler (for continuous mode)
engine.setBTActionHandler(handler: (npcId: string, action: BTAction) => void): void
```

### QuestManager Methods

```typescript
// Check stage-level state
quests.getStageState(questId: string, stageId: string): 'active' | 'completed' | null

// Check individual beat node state
quests.getObjectiveState(questId: string, objectiveId: string): 'active' | 'completed' | null
```

### Custom Conditions and Actions

Built-in conditions (`questStage`, `hasItem`, `hasFlag`) are evaluated through the [World State System](./014-world-state.md). Built-in actions (`dialogue`, `moveTo`, `wait`, `setFlag`, `emitEvent`) are handled automatically. `setFlag` actions write to `game.flags` (the `FlagsManager`), which triggers automatic condition re-evaluation. For custom types:

```typescript
// Custom condition - return true/false
engine.setBTConditionChecker((npcId, condition) => {
  if (condition.type === 'custom' && condition.check === 'isRaining') {
    return weatherSystem.isRaining();
  }
  // Return false for unhandled conditions (built-ins are handled before this)
  return false;
});

// Custom action - do something when the action fires
engine.setBTActionHandler((npcId, action) => {
  if (action.type === 'custom' && action.handler === 'startMinigame') {
    minigameSystem.start(action.params);
  }
});
```

## NPCBehavior Component

**Source**: `src/components/NPCBehavior.ts`

```typescript
new NPCBehavior(
  tree: BTNode,
  mode: 'onInteraction' | 'continuous',
  tickInterval?: number  // ms between ticks, default 1000
)
```

| Property | Type | Description |
|----------|------|-------------|
| `tree` | `BTNode` | Root node of the behavior tree |
| `mode` | `BehaviorMode` | When the tree evaluates |
| `tickInterval` | `number` | Milliseconds between continuous ticks |
| `blackboard` | `Map<string, unknown>` | Per-NPC local state |

## BehaviorTreeSystem

**Source**: `src/systems/BehaviorTreeSystem.ts`

Ticks all NPCs with `continuous` mode behavior trees. Tracks running actions (`wait` timers, `moveTo` completion).

The system is registered automatically when the engine starts. It evaluates trees using the condition checker and action handler callbacks set on the engine.

## Data Types

**Source**: `src/behavior/types.ts`

All behavior tree types are exported from the engine:

```typescript
import {
  BTNode, BTNodeType, BTStatus, BTResult, BTContext,
  BTControlNode, BTParallelNode, BTDecoratorNode,
  BTConditionNode, BTActionNode,
  BTCondition, BTConditionType,
  BTAction, BTActionType,
  BehaviorTreeEvaluator,
  NPCBehavior, BehaviorMode,
  BehaviorTreeSystem, BTConditionChecker, BTActionHandler,
} from 'sugarengine';
```
